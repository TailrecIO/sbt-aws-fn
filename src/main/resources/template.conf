
aws {
  s3 {
    region = "us-west-2"
    www {

    }
  }

  iam {
    region = "us-west-2"
    roles = {
      lambda_basic_execution = {
        policy =
          {
            "Version": "2012-10-17",
            "Statement":[
              {
                "Sid": "",
                "Effect": "Allow",
                "Principal": {"Service": "lambda.amazonaws.com"},
                "Action": "sts:AssumeRole"
              }
            ]
          }
      }
    }
  }

  lambda {

    minified = true
    s3Bucket = ""

    default {
      region = "us-west-2"
      memory = 128
      timeout = 30
      # Amazon Resource Name (ARN) of the IAM role for the Lambda function
      # role can be either a name or ARN.
      role = "lambda_basic_execution"
    }

# Use this artifact configuration to create a new bucket when the region of `lambda.default.region` is different
# from `functions.${functionId}.region`. The `groupName` attribute must match `artifactGroup` in function definition.
# Since bucket name is globally unique, you cannot use the same bucket name across regions. If you are willing to deploy
# a lambda function to a different region, you have to use this configuration to map the artifact with the S3 bucket
# which is created in the same region as a lambda function.
# If a bucket does not exist, the tool will try to create it.
//    artifacts = {
//      groupName = {
//        s3Region = "us-west-1"
//        s3Bucket = "unique-bucket-name"
//      }
//    }

    # Function definitions are declared as a map. So, you can split
    functions = {
      # A function ID.
      function1 = {
        # A function name. If you omit this attribute, the function ID (function1) will be used as a name.
        name = "hello-function"
        # The artifactGroup is optional. If you specify this value, it is implied that you want to minify the artifact.
        # Proguard will keep only classes that are required by this function and discard the rest. So, the fat jar
        # should be shrinked substantially.
        # You can share the same artifactGroup, and Proguard will keep all classes that are used by functions
        # sharing the same artifactGroup. This configuration gives you the fine-grained control to group and optimize
        # your artifact file.
        //artifactGroup = "artifact1"
        description = ""
        handler {
          # A fully qualified class name of the function.
          className = "com.example.Lambda"
          # A method name of a function
          methodName = "hello"
          # A fully qualified class name of a return type (i.e. java.lang.String)
          # If you omit this attribute, void or unit will be assumed.
          returnType = "java.lang.String"
        }
        # You can override the default values
        //region = "your own region"
        //role = "your custom role"
        //memory = 192
        //timeout = 10
      }
      //function2 = {
        //handler {
          //className = ""
          //methodName = ""
        //}
      //}
    }

    events {
      http {
        apiName = ""
        resourceName = ""
        method = ""
        deploymentStage = ""
        security = ""
      }
    }
  }
}

